<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="siyuan-api-endpoint" content="/api/rpc/:channel/*path"> <!-- API Endpoint Meta Tag -->
    <title>外部请求 RPC 代理 - 思源笔记 API 文档</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <header>
        <h1>外部请求 RPC 代理 (handleExternalRequest)</h1>
        <nav>
            <a href="../index.html">首页</a> | 
            <a href="index.html">RPC API</a> |
            <a href="https://github.com/siyuan-note/siyuan/blob/master/kernel/api/rpc.go#L108" target="_blank">GitHub Source</a>
        </nav>
    </header>
    <main>
        <section id="description">
            <h2>功能描述</h2>
            <p>此 API 端点 <code>GET /api/rpc/:channel/*path</code> 和 <code>POST /api/rpc/:channel/*path</code> 充当一个通用的**远程过程调用 (RPC) 代理**。</p>
            <p>它的主要作用是接收一个标准的 HTTP 请求，然后将该请求的信息封装并转发给内部一个由 <code>:channel</code> 参数指定的 WebSocket 通道。它会等待该 WebSocket 通道返回响应，并将响应内容（状态码、头部、主体）包装成 HTTP 响应返回给原始请求者。</p>
            <p>这使得外部应用、插件或服务可以通过发送 HTTP 请求的方式，来调用思源笔记后端通过 WebSocket 提供的服务，而无需直接建立和管理 WebSocket 连接。</p>
            <p><strong>关键点：</strong></p>
            <ul>
                <li><strong>代理性质：</strong> 此 API 本身不处理具体业务逻辑，仅负责转发请求和响应。</li>
                <li><strong>动态路径：</strong> <code>:channel</code> 指定了目标 WebSocket 通道名称；<code>*path</code> 捕获了 `/api/rpc/:channel/` 之后的所有路径段，通常用于指示要调用的具体 RPC 方法或资源。</li>
                <li><strong>请求封装：</strong> HTTP 请求信息（头、查询参数、方法、主体等）会被打包成 JSON 发送到 WebSocket。</li>
                <li><strong>响应处理：</strong> 从 WebSocket 收到的 JSON 响应中提取状态码、头部和主体（支持 base64, hex, json 编码）来构建 HTTP 响应。</li>
                <li><strong>无内置认证：</strong> 该路由没有应用标准的认证中间件，意味着访问控制可能需要在 WebSocket 服务端实现，或者依赖于网络环境/部署策略。</li>
            </ul>
            <p><strong>使用场景：</strong> 主要用于插件或其他需要与思源后端进行复杂交互的外部服务。</p>
        </section>

        <section id="request-parameters">
            <h2>请求参数</h2>
            <h3>URL 参数</h3>
            <ul>
                <li><code>:channel</code> (string): <strong>必填</strong>。URL 路径中的一部分，用于指定目标 WebSocket 通道的名称。</li>
                <li><code>*path</code> (string): <strong>必填</strong>。URL 路径中的一部分，捕获 <code>:channel</code> 之后的所有路径段，通常代表要调用的 RPC 方法或目标资源。</li>
            </ul>
            <h3>查询参数 (GET)</h3>
            <p>所有 GET 请求的查询参数会被封装并转发给 WebSocket 服务。</p>
            <h3>请求体 (POST)</h3>
            <p>POST 请求的请求体（任何类型）会被读取并封装，然后转发给 WebSocket 服务。</p>
            <p><strong>请求示例 (假设调用 'myplugin' 通道的 'doSomething' 方法):</strong></p>
            <p><code>POST /api/rpc/myplugin/doSomething?param1=value1</code></p>
            <pre><code class="language-json">{
  "arg1": 123,
  "arg2": "hello"
}
            </code></pre>
            <p>在这个例子中：</p>
            <ul>
                <li><code>:channel</code> 是 "myplugin"</li>
                <li><code>*path</code> 是 "doSomething"</li>
                <li>查询参数 <code>param1=value1</code> 会被转发</li>
                <li>请求体 JSON 对象会被转发</li>
            </ul>
        </section>

        <section id="response-format">
            <h2>响应结果</h2>
            <p>响应结果完全取决于连接到指定 <code>:channel</code> 的 WebSocket 服务返回的内容。</p>
            <p>此 API 会尝试解析 WebSocket 返回的 JSON 消息，提取 <code>statusCode</code>, <code>headers</code>, 和经过编码的 <code>body</code>，然后构建相应的 HTTP 响应。</p>
            <p><strong>成功响应示例 (假设 WebSocket 返回了 HTML 内容):</strong></p>
            <p>HTTP 状态码: 200 OK</p>
            <p>响应头: Content-Type: text/html; charset=utf-8</p>
            <p>响应体:</p>
            <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;Hello from WebSocket!&lt;/body&gt;
&lt;/html&gt;
            </code></pre>
            <p><strong>失败响应示例 (通道未找到):</strong></p>
            <p>HTTP 状态码: 404 Not Found</p>
            <pre><code class="language-json">
{
  "error": "Channel not found"
}
            </code></pre>
             <p><strong>失败响应示例 (请求超时):</strong></p>
            <p>HTTP 状态码: 504 Gateway Timeout</p>
            <pre><code class="language-text">Request timed out
            </code></pre>
            <p>其他可能的错误包括请求体读取失败、序列化/反序列化失败、WebSocket 广播失败、响应解码失败等。</p>
        </section>

        <section id="online-testing">
            <h2>在线测试</h2>
            <p class="warning"><strong>警告：</strong>这是一个通用的 RPC 代理端点。直接调用需要您非常清楚目标 <code>channel</code> 和 <code>path</code> 的预期行为，以及相应的 WebSocket 服务端实现。不正确的调用可能导致错误或无响应。</p>
            <div class="api-tester">
                <label for="api-token">API Token:</label>
                <input type="text" id="api-token" placeholder="Token 可能由 WebSocket 服务端处理 (可选)" value=""><br>

                <label for="endpoint">Endpoint:</label>
                <input type="text" id="endpoint" placeholder="/api/rpc/your-channel/your/path" value=""><br>

                <label for="method">Method:</label>
                <select id="method">
                    <option value="POST">POST</option>
                    <option value="GET">GET</option>
                    <!-- 可以添加其他方法，但后端主要处理 GET/POST -->
                </select><br>

                <label for="params">Query Parameters (for GET):</label><br>
                <input type="text" id="query-params" placeholder="param1=value1&param2=value2" style="width: 80%;"><br>

                <label for="params">Request Body (for POST):</label><br>
                <textarea id="params" rows="8" placeholder='{
  "key": "value"
}'></textarea><br>

                <button onclick="sendRpcRequest()" style="background-color: #ff9800;">发送请求 (谨慎操作)</button>

                <h3>响应结果:</h3>
                <pre id="response-output"></pre>
            </div>
        </section>
    </main>
    <footer>
        <p>思源笔记 API 文档 | 最后更新时间：<span id="last-updated"></span></p>
    </footer>
    <script src="../script.js"></script>
    <script>
        // 更新最后更新时间
        document.getElementById('last-updated').textContent = new Date().toLocaleString();

        // 特殊的发送函数，处理动态 Endpoint 和查询参数
        function sendRpcRequest() {
            const token = document.getElementById('api-token').value;
            let endpoint = document.getElementById('endpoint').value;
            const method = document.getElementById('method').value;
            const queryParams = document.getElementById('query-params').value;
            const body = document.getElementById('params').value;
            const output = document.getElementById('response-output');

            output.textContent = '正在发送请求...';

            const headers = {
                'Content-Type': 'application/json',
            };
            if (token) {
                headers['Authorization'] = `Token ${token}`;
            }

            let url = endpoint;
            if (method === 'GET' && queryParams) {
                url += (endpoint.includes('?') ? '&' : '?') + queryParams;
            }

            const fetchOptions = {
                method: method,
                headers: headers,
            };

            if (method !== 'GET' && body) {
                fetchOptions.body = body;
                // 尝试自动设置 Content-Type
                try {
                    JSON.parse(body);
                    headers['Content-Type'] = 'application/json';
                } catch (e) {
                    // 如果不是 JSON，假设是普通文本
                    headers['Content-Type'] = 'text/plain';
                }
            }

            fetch(url, fetchOptions)
                .then(response => {
                    output.textContent = `状态码: ${response.status} ${response.statusText}\n`;
                    output.textContent += '响应头:\n';
                    response.headers.forEach((value, key) => {
                        output.textContent += `  ${key}: ${value}\n`;
                    });
                    output.textContent += '\n响应体:\n';
                    return response.text(); // 获取文本格式的响应体
                })
                .then(text => {
                    // 尝试格式化 JSON
                    try {
                        const json = JSON.parse(text);
                        output.textContent += JSON.stringify(json, null, 2);
                    } catch (e) {
                        output.textContent += text; // 如果不是 JSON，直接显示文本
                    }
                })
                .catch(error => {
                    output.textContent = `请求出错: ${error}`;
                });
        }
    </script>
</body>
</html> 